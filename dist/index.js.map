{"version":3,"sources":["../src/providers/wallet.ts","../src/actions/transfer.ts","../src/types/index.ts","../src/types/precompiles.ts","../src/index.ts"],"sourcesContent":["import {\n    createPublicClient,\n    createWalletClient,\n    formatUnits,\n    http,\n} from \"viem\";\nimport { privateKeyToAccount } from \"viem/accounts\";\nimport {\n    type IAgentRuntime,\n    type Provider,\n    type Memory,\n    type State,\n    type ICacheManager,\n    elizaLogger,\n} from \"@elizaos/core\";\nimport type {\n    Address,\n    WalletClient,\n    PublicClient,\n    Chain,\n    HttpTransport,\n    Account,\n    PrivateKeyAccount,\n    TestClient,\n} from \"viem\";\nimport * as viemChains from \"viem/chains\";\nimport NodeCache from \"node-cache\";\nimport * as path from \"node:path\";\n\nimport type { ChainWithName } from \"../types\";\n\nexport const seiChains = {\n    \"mainnet\": viemChains.sei,\n    \"testnet\": viemChains.seiTestnet,\n    \"devnet\": viemChains.seiDevnet,\n}\n\nexport class WalletProvider {\n    private cache: NodeCache;\n    // private cacheKey: string = \"evm/wallet\";\n    private cacheKey = \"evm/wallet\"; // Remove explicit type annotation\n    private currentChain: ChainWithName;\n    private CACHE_EXPIRY_SEC = 5;\n    account: PrivateKeyAccount;\n\n    constructor(\n        accountOrPrivateKey: PrivateKeyAccount | `0x${string}`,\n        private cacheManager: ICacheManager,\n        chain: ChainWithName,\n    ) {\n        this.setAccount(accountOrPrivateKey);\n\n        this.setCurrentChain(chain);\n\n        this.cache = new NodeCache({ stdTTL: this.CACHE_EXPIRY_SEC });\n    }\n\n    getAddress(): Address {\n        return this.account.address;\n    }\n\n    getCurrentChain(): ChainWithName {\n        return this.currentChain;\n    }\n\n    getPublicClient(): PublicClient<HttpTransport, Chain, Account | undefined> {\n        const transport = this.createHttpTransport();\n\n        const publicClient = createPublicClient({\n            chain: this.currentChain.chain,\n            transport,\n        });\n\n        return publicClient;\n    }\n\n    getEvmWalletClient(): WalletClient {\n        const transport = this.createHttpTransport();\n\n        const walletClient = createWalletClient({\n            chain: this.currentChain.chain,\n            transport,\n            account: this.account,\n        });\n\n        return walletClient;\n    }\n\n    getEvmPublicClient() {\n        const transport = this.createHttpTransport();\n\n        const publicClient = createPublicClient({\n            chain: this.currentChain.chain,\n            transport: transport,\n        });\n\n        return publicClient\n    }\n\n    async getWalletBalance(): Promise<string | null> {\n        const cacheKey = `seiWalletBalance_${this.currentChain.name}`; // Fix: Use template literal\n        const cachedData = await this.getCachedData<string>(cacheKey);\n        if (cachedData) {\n            elizaLogger.log(\n                `Returning cached wallet balance for sei chain: ${this.currentChain.name}` // Fix: Use template literal\n            );\n            return cachedData;\n        }\n\n        try {\n            const client = this.getPublicClient();\n            const balance = await client.getBalance({\n                address: this.account.address,\n            });\n            const balanceFormatted = formatUnits(balance, 18);\n            this.setCachedData<string>(cacheKey, balanceFormatted);\n            elizaLogger.log(\n                \"Wallet balance cached for chain: \",\n                this.currentChain.name\n            );\n            return balanceFormatted;\n        } catch (error) {\n            console.error(\"Error getting wallet balance:\", error);\n            return null;\n        }\n    }\n\n    private async readFromCache<T>(key: string): Promise<T | null> {\n        const cached = await this.cacheManager.get<T>(\n            path.join(this.cacheKey, key)\n        );\n        return cached ?? null; // Fix: Return null if cached is undefined\n    }\n    \n    // private async readFromCache<T>(key: string): Promise<T | null> {\n    //     const cached = await this.cacheManager.get<T>(\n    //         path.join(this.cacheKey, key)\n    //     );\n    //     return cached;\n    // }\n\n    private async writeToCache<T>(key: string, data: T): Promise<void> {\n        await this.cacheManager.set(path.join(this.cacheKey, key), data, {\n            expires: Date.now() + this.CACHE_EXPIRY_SEC * 1000,\n        });\n    }\n\n    private async getCachedData<T>(key: string): Promise<T | null> {\n        // Check in-memory cache first\n        const cachedData = this.cache.get<T>(key);\n        if (cachedData) {\n            return cachedData;\n        }\n\n        // Check file-based cache\n        const fileCachedData = await this.readFromCache<T>(key);\n        if (fileCachedData) {\n            // Populate in-memory cache\n            this.cache.set(key, fileCachedData);\n            return fileCachedData;\n        }\n\n        return null;\n    }\n\n    private async setCachedData<T>(cacheKey: string, data: T): Promise<void> {\n        // Set in-memory cache\n        this.cache.set(cacheKey, data);\n\n        // Write to file-based cache\n        await this.writeToCache(cacheKey, data);\n    }\n\n    private setAccount = (\n        accountOrPrivateKey: PrivateKeyAccount | `0x${string}`\n    ) => {\n        if (typeof accountOrPrivateKey === \"string\") {\n            this.account = privateKeyToAccount(accountOrPrivateKey);\n        } else {\n            this.account = accountOrPrivateKey;\n        }\n    };\n\n    private setCurrentChain = (chain: ChainWithName) => {\n        this.currentChain = chain;\n    };\n\n    private createHttpTransport = () => {\n        const chain = this.currentChain.chain;\n\n        if (chain.rpcUrls.custom) {\n            return http(chain.rpcUrls.custom.http[0]);\n        }\n        return http(chain.rpcUrls.default.http[0]);\n    };\n\n    static genSeiChainFromName(\n        chainName: string,\n        customRpcUrl?: string | null\n    ): Chain {\n        const baseChain = seiChains[chainName];\n\n        if (!baseChain?.id) {\n            throw new Error(\"Invalid chain name\");\n        }\n\n        const seiChain: Chain = customRpcUrl\n            ? {\n                  ...baseChain,\n                  rpcUrls: {\n                      ...baseChain.rpcUrls,\n                      custom: {\n                          http: [customRpcUrl],\n                      },\n                  },\n              }\n            : baseChain;\n\n        return seiChain;\n    }\n}\nconst genChainFromRuntime = (\n    runtime: IAgentRuntime\n): ChainWithName => {\n    const sei_network = runtime.getSetting(\"SEI_NETWORK\");\n    if (typeof sei_network !== \"string\") { // Fix: Ensure sei_network is a string\n        throw new Error(\"SEI_NETWORK must be a string\");\n    }\n\n    const validChains = Object.keys(seiChains);\n    if (!validChains.includes(sei_network)) {\n        throw new Error(`Invalid SEI_NETWORK ${sei_network}. Must be one of ${validChains.join(\", \")}`);\n    }\n\n    let chain = seiChains[sei_network];\n    const rpcurl = runtime.getSetting(\"SEI_RPC_URL\");\n    if (typeof rpcurl === \"string\") { // Fix: Ensure rpcurl is a string\n        chain = WalletProvider.genSeiChainFromName(sei_network, rpcurl);\n    }\n\n    return { name: sei_network, chain: chain }; // Fix: Ensure name is always a string\n};\n\n// const genChainFromRuntime = (\n//     runtime: IAgentRuntime\n// ): ChainWithName => {\n//     const sei_network = runtime.getSetting(\"SEI_NETWORK\");\n//     const validChains = Object.keys(seiChains)\n//     if (!validChains.includes(sei_network)) {\n//         // throw new Error(\"Invalid SEI_NETWORK \" + sei_network + \" Must be one of \" + validChains.join(\", \"));\n//         throw new Error(`Invalid SEI_NETWORK ${sei_network}. Must be one of ${validChains.join(\", \")}`);\n//     }\n\n//     let chain = seiChains[sei_network]\n//     const rpcurl = runtime.getSetting(\"SEI_RPC_URL\");\n//     if (rpcurl) {\n//         chain = WalletProvider.genSeiChainFromName(\n//             sei_network,\n//             rpcurl\n//         );\n//     }\n\n//     return {name: sei_network, chain: chain};\n// };\n\nexport const initWalletProvider = async (runtime: IAgentRuntime) => {\n\n    const chainData = genChainFromRuntime(runtime)\n    const privateKey = runtime.getSetting(\n        \"SEI_PRIVATE_KEY\"\n    ) as `0x${string}`;\n    if (!privateKey) {\n        throw new Error(\"SEI_PRIVATE_KEY is missing\");\n    }\n    return new WalletProvider(privateKey, runtime.cacheManager, chainData);\n};\n\nexport const evmWalletProvider: Provider = {\n    async get(\n        runtime: IAgentRuntime,\n        _message: Memory,\n        state?: State\n    ): Promise<string | null> {\n        try {\n            const walletProvider = await initWalletProvider(runtime);\n            const address = walletProvider.getAddress();\n            const balance = await walletProvider.getWalletBalance();\n            const chain = walletProvider.getCurrentChain().chain;\n            const agentName = state?.agentName || \"The agent\";\n            return `${agentName}'s Sei Wallet Address: ${address}\\nBalance: ${balance} ${chain.nativeCurrency.symbol}\\nChain ID: ${chain.id}, Name: ${chain.name}`;\n        } catch (error) {\n            console.error(\"Error in Sei wallet provider:\", error);\n            return null;\n        }\n    },\n};\n","import { ByteArray, formatEther, parseEther, type Hex } from \"viem\";\nimport {\n    elizaLogger,\n    Action,\n    composeContext,\n    generateObjectDeprecated,\n    HandlerCallback,\n    ModelClass,\n    type IAgentRuntime,\n    type Memory,\n    type State,\n} from \"@elizaos/core\";\n\nimport { initWalletProvider, WalletProvider } from \"../providers/wallet\";\nimport { ADDRESS_PRECOMPILE_ABI, ADDRESS_PRECOMPILE_ADDRESS, type Transaction, type TransferParams } from \"../types\";\n\nexport const transferTemplate = `You are an AI assistant specialized in processing cryptocurrency transfer requests. Your task is to extract specific information from user messages and format it into a structured JSON response.\n\nFirst, review the recent messages from the conversation:\n\n<recent_messages>\n{{recentMessages}}\n</recent_messages>\n\nYour goal is to extract the following information about the requested transfer:\n1. Amount to transfer in SEI\n2. Recipient address\n\nBefore providing the final JSON output, show your reasoning process inside <analysis> tags. Follow these steps:\n\n1. Identify the relevant information from the user's message:\n   - Quote the part mentioning the amount.\n   - Quote the part mentioning the recipient address.\n\n2. Validate each piece of information:\n   - Amount: Attempt to convert the amount to a number to verify it's valid.\n   - Address: Check that it either starts with \"0x\" or \"sei1\", and ensure that the address contains 42 characters,\n   - Chain: Check that the chain is either mainnet, testnet, devnet or\n\n3. If any information is missing or invalid, prepare an appropriate error message.\n\n4. If all information is valid, summarize your findings.\n\n5. Prepare the JSON structure based on your analysis.\n\nAfter your analysis, provide the final output in a JSON markdown block. All fields except 'token' are required. The JSON should have this structure:\n\\`\\`\\`json\n{\n    \"amount\": string,\n    \"toAddress\": string,\n}\n\\`\\`\\`\n\nRemember:\n- The amount should be a string representing the SEI amount without any currency symbol.\n- The recipient address must be a valid Ethereum address starting with \"0x\" or a vald SEI address startng with \"sei1\".\n\nNow, process the user's request and provide your response.\n`;\n\n// Exported for tests\nexport class TransferAction {\n    constructor(private walletProvider: WalletProvider) {}\n\n    async transfer(params: TransferParams): Promise<Transaction> {\n        const chain = this.walletProvider.getCurrentChain()\n        elizaLogger.log(\n            `Transferring: ${params.amount} tokens to (${params.toAddress} on ${chain.name})`\n        );\n        // let recipientAddress\n        let recipientAddress: `0x${string}`; // Ensure it's a valid Ethereum address\n\n        if (params.toAddress.startsWith(\"sei\")) {\n            const publicClient = this.walletProvider.getEvmPublicClient();\n            const evmAddress = await publicClient.readContract({\n                address: ADDRESS_PRECOMPILE_ADDRESS,\n                abi: ADDRESS_PRECOMPILE_ABI,\n                functionName: 'getEvmAddr',\n                args: [params.toAddress],\n            });\n\n            if (!evmAddress || !evmAddress.startsWith(\"0x\")) {\n                throw new Error(`ERROR: Recipient does not have valid EVM address. Got: ${evmAddress}`);\n            }\n\n            elizaLogger.log(`Translated address ${params.toAddress} to EVM address ${evmAddress}`);\n            recipientAddress = evmAddress as `0x${string}`; // Ensure it's a valid Ethereum address\n        } else {\n            if (!params.toAddress.startsWith(\"0x\")) {\n                throw new Error(`ERROR: Recipient address must start with '0x'. Got: ${params.toAddress}`);\n            }\n            recipientAddress = params.toAddress as `0x${string}`; // Ensure it's a valid Ethereum address\n        }\n\n        const walletClient = this.walletProvider.getEvmWalletClient();\n        if (!walletClient.account) {\n            throw new Error(\"Wallet client account is undefined\");\n        }\n\n        try {\n            const hash = await walletClient.sendTransaction({\n                account: walletClient.account,\n                to: recipientAddress,\n                value: parseEther(params.amount),\n                data: params.data as Hex,\n\n                kzg: {\n                    blobToKzgCommitment: (_: ByteArray): ByteArray => {\n                        throw new Error(\"Function not implemented.\");\n                    },\n                    computeBlobKzgProof: (\n                        _blob: ByteArray,\n                        _commitment: ByteArray\n                    ): ByteArray => {\n                        throw new Error(\"Function not implemented.\");\n                    },\n                },\n                maxFeePerBlobGas: BigInt(0), // Add required property\n                blobs: [], // Add required property\n                chain: undefined,\n            });\n                // kzg: {\n                //     blobToKzgCommitment: function (_: ByteArray): ByteArray {\n                //         throw new Error(\"Function not implemented.\");\n                //     },\n                //     computeBlobKzgProof: function (\n                //         _blob: ByteArray,\n                //         _commitment: ByteArray\n                //     ): ByteArray {\n                //         throw new Error(\"Function not implemented.\");\n                //     },\n                // },\n\n\n            return {\n                hash,\n                from: walletClient.account.address, // Now guaranteed to be defined\n                to: params.toAddress,\n                value: parseEther(params.amount),\n                data: params.data as Hex,\n            };\n\n        } catch (error) {\n            throw new Error(`Transfer failed: ${error.message}`);\n        }\n    }\n}\n\nconst buildTransferDetails = async (\n    state: State,\n    runtime: IAgentRuntime,\n    _wp: WalletProvider\n): Promise<TransferParams> => {\n    const context = composeContext({\n        state,\n        template: transferTemplate,\n    });\n\n    const transferDetails = (await generateObjectDeprecated({\n        runtime,\n        context,\n        modelClass: ModelClass.SMALL,\n    })) as TransferParams;\n\n    return transferDetails;\n};\n\nexport const transferAction: Action = {\n    name: \"transfer\",\n    description: \"Transfer tokens between addresses on the same chain\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: Record<string, unknown>, // Replace `any` with a safer type\n        callback?: HandlerCallback\n    ) => {\n        \n        // Create a new variable to avoid reassigning the parameter\n        let updatedState = state;\n        \n        if (!updatedState) {\n            updatedState = (await runtime.composeState(message)) as State;\n        } else {\n            updatedState = await runtime.updateRecentMessageState(updatedState);\n        }\n\n        elizaLogger.debug(\"Transfer action handler called\");\n        const walletProvider = await initWalletProvider(runtime);\n        const action = new TransferAction(walletProvider);\n\n        // Compose transfer context\n        const paramOptions = await buildTransferDetails(\n            updatedState, // Use the new variable\n            runtime,\n            walletProvider\n        );\n        \n        // // Compose transfer context\n        // const paramOptions = await buildTransferDetails(\n        //     state,\n        //     runtime,\n        //     walletProvider\n        // );\n\n        try {\n            const transferResp = await action.transfer(paramOptions);\n            if (callback) {\n                callback({\n                    text: `Successfully transferred ${paramOptions.amount} tokens to ${paramOptions.toAddress}\\nTransaction Hash: ${transferResp.hash}`,\n                    content: {\n                        success: true,\n                        hash: transferResp.hash,\n                        amount: formatEther(transferResp.value),\n                        recipient: transferResp.to,\n                        chain: walletProvider.getCurrentChain().name,\n                    },\n                });\n            }\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error during token transfer:\", error);\n            if (callback) {\n                callback({\n                    text: `Error transferring tokens: ${error.message}`,\n                    content: { error: error.message },\n                });\n            }\n            return false;\n        }\n    },\n    validate: async (runtime: IAgentRuntime) => {\n        const privateKey = runtime.getSetting(\"SEI_PRIVATE_KEY\");\n        return typeof privateKey === \"string\" && privateKey.startsWith(\"0x\");\n    },\n    examples: [\n        [\n            {\n                user: \"assistant\",\n                content: {\n                    text: \"I'll help you transfer 1 SEI to 0x742d35Cc6634C0532925a3b844Bc454e4438f44e\",\n                    action: \"SEND_TOKENS\",\n                },\n            },\n            {\n                user: \"user\",\n                content: {\n                    text: \"Transfer 1 SEI to 0x742d35Cc6634C0532925a3b844Bc454e4438f44e\",\n                    action: \"SEND_TOKENS\",\n                },\n            },\n        ],\n    ],\n    similes: [\"SEND_TOKENS\", \"TOKEN_TRANSFER\", \"MOVE_TOKENS\", \"SEND_SEI\"],\n};\n","import type { Token } from \"@lifi/types\";\nimport type {\n    Account,\n    Address,\n    Chain,\n    Hash,\n    HttpTransport,\n    PublicClient,\n    WalletClient,\n} from \"viem\";\nimport * as viemChains from \"viem/chains\";\nexport * from \"./precompiles\"\n\nconst _SupportedChainList = Object.keys([viemChains.seiDevnet, viemChains.seiTestnet, viemChains.sei]) as Array<\n    keyof typeof viemChains\n>;\n\nexport interface ChainWithName {\n    name: string;\n    chain: Chain\n}\n\n// Transaction types\nexport interface Transaction {\n    hash: Hash;\n    from: Address;\n    to: string;\n    value: bigint;\n    data?: `0x${string}`;\n    chainId?: number;\n}\n\n// Token types\nexport interface TokenWithBalance {\n    token: Token;\n    balance: bigint;\n    formattedBalance: string;\n    priceUSD: string;\n    valueUSD: string;\n}\n\nexport interface WalletBalance {\n    chain: string;\n    address: Address;\n    totalValueUSD: string;\n    tokens: TokenWithBalance[];\n}\n\nexport interface ChainConfig {\n    chain: Chain;\n    publicClient: PublicClient<HttpTransport, Chain, Account | undefined>;\n    walletClient?: WalletClient;\n}\n\n// Action parameters\nexport interface TransferParams {\n    toAddress: string;\n    amount: string;\n    data?: `0x${string}`;\n}\n\n// Provider types\nexport interface TokenData extends Token {\n    symbol: string;\n    decimals: number;\n    address: Address;\n    name: string;\n    logoURI?: string;\n    chainId: number;\n}\n\nexport interface ProviderError extends Error {\n    code?: number;\n    data?: unknown;\n}","export const ADDRESS_PRECOMPILE_ABI = [\n\t{\n\t\tinputs: [{ internalType: 'string', name: 'addr', type: 'string' }],\n\t\tname: 'getEvmAddr',\n\t\toutputs: [{ internalType: 'address', name: 'response', type: 'address' }],\n\t\tstateMutability: 'view',\n\t\ttype: 'function'\n\t},\n\t{\n\t\tinputs: [{ internalType: 'address', name: 'addr', type: 'address' }],\n\t\tname: 'getSeiAddr',\n\t\toutputs: [{ internalType: 'string', name: 'response', type: 'string' }],\n\t\tstateMutability: 'view',\n\t\ttype: 'function'\n\t},\n\t{\n\t\tinputs: [{ internalType: 'string', name: 'v', type: 'string' }, { internalType: 'string', name: 'r', type: 'string' }, { internalType: 'string', name: 's', type: 'string' }, { internalType: 'string', name: 'customMessage', type: 'string' }],\n\t\tname: 'associate',\n\t\toutputs: [{ internalType: 'string', name: 'seiAddr', type: 'string' }, { internalType: 'address', name: 'evmAddr', type: 'address' }],\n\t\tstateMutability: 'nonpayable',\n\t\ttype: 'function'\n\t},\n\t{\n\t\tinputs: [{ internalType: 'string', name: 'pubKeyHex', type: 'string' }],\n\t\tname: 'associatePubKey',\n\t\toutputs: [{ internalType: 'string', name: 'seiAddr', type: 'string' }, { internalType: 'address', name: 'evmAddr', type: 'address' }],\n\t\tstateMutability: 'nonpayable',\n\t\ttype: 'function'\n\t},\n] as const;\n\nexport const ADDRESS_PRECOMPILE_ADDRESS: `0x${string}` = '0x0000000000000000000000000000000000001004'","import type { Plugin } from \"@elizaos/core\";\nimport { evmWalletProvider } from \"./providers/wallet.ts\";\n\nimport { transferAction } from \"./actions/transfer\";\n\nconsole.log(\"SEI IS BEING INITIALIZED\")\n\nexport const seiPlugin: Plugin = {\n    name: \"sei\",\n    description: \"Sei Plugin for Eliza\",\n    actions: [transferAction],\n    evaluators: [],\n    providers: [evmWalletProvider],\n};\n\nexport default seiPlugin;\n"],"mappings":"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","names":["elizaLogger","viemChains","elizaLogger"]}